= Go Generics
:page-tags: go generics
:favicon: https://fernandobasso.dev/cmdline.png
:icons: font
:sectlinks:
:sectnums!:
:toclevels: 6
:source-highlighter: highlight.js
:experimental:
:stem: latexmath
:toc: left
:imagesdir: __assets
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

== Intro

Go 1.18 introduced generics support.
From that version, functions can take generic (parametrically polymorphic) types, and interfaces got the ability to describe union types.

== min(x, y) for go 1.18

.go.mod
[source,go]
----
module main

go 1.18

require golang.org/x/exp v0.0.0-20250128182459-e0ece0dbea4c
----

.main.go
[source,go]
----
package main

import (
	"golang.org/x/exp/constraints"
	"fmt"
)

func min[T constraints.Ordered](x, y T) T {
	if x < y {
		return x
	}

	return y
}

func main() {
	fmt.Println(min[int](3, 2))
	// => 2

	fmt.Println(min[string]("xyz", "klm"))
	// => klm

	// '_' is 95, '0' is 48 (like in C/ASCII)
	fmt.Println(min[rune]('_', '0'))
	// => 48
}
----

Observe that we pass the concrete type when calling `min`, like `min[int](...)`, `min[string](...)` and `min[rune](...)` in our example.
Providing that concrete type while calling the function is called _instantiation_.

Instantiation happens in two steps:

* Substitute type argument for type parameters.
* Check that type arguments implement their constraints.

And if step two fails, instantiation itself fails.

[NOTE]
====
Due to type inference, it is not always required to pass the concrete type while calling the function.
Instantiation can infer types most of the time.
It means this could would also work:

[source,go]
----
fmt.Println(min(3, 2))
// => 2

fmt.Println(min("xyz", "klm"))
// => klm

// '_' is 95, '0' is 48 (like in C/ASCII)
fmt.Println(min('_', '0'))
----
====

== Go 1.21 cmp.Ordered

From Go 1.21, `cmp.Ordered` is the type we should use:

[source,go]
----
import "cmp"

func min[T cmp.Ordered](x, y T) T {
	if x < y {
		return x
	}

	return y
}
----

The instantiation and usage is the same as the previous example with `constraints.Ordered`.

== Instantiation examples

It is possible to instantiate the generic function with a concrete type (without actually calling it).
The instantiation produces a non-generic function, which can be assigned to a variable for later use.

[source,go]
----
var minInt8 = min[int8]
var minStr = min[string]

func main() {
	fmt.Println(minInt8(7, 2))
	// => 2

	fmt.Println(minStr("abc", "KLM"))
	// KLM
}
----

== Generic structs

=== Example with a binary tree

[source,go]
----
type Tree[T any] struct {
	left, right *Tree[T]
	data        T
}
----

Then we could implement methods on `Tree`:

[source,go]
----
func (t *Tree[T]) Find(v T) *Tree[T] {
	// Logic to find v.
}
----

And create concrete-typed instances from the generic `Tree[T]`.
That is, we can instanticate `T` to any concrete type that (in our example), satisfies the `cmp.Ordered` interface:

[source,go]
----
var sTree Tree[string]
var iTree Tree[int64]
----

[NOTE]
====
Remember that `any` is short for `interface{}`.
====

== Type sets and type constraints

An ordinary parameter list has a type for each parameter.
This type defines a set of values that inhabit that type (all possible strings, or all possible integer numbers, etc.)

[source,go]
----
func min(x, y int64) int64 {
	// ...
}
----

In the `min()` function above, `int64` is the type for both `x` and `y`, it it means that both `x` and `y` can take any of the values that inhabit the `int64` type.

Compare with this:

[source,go]
----
func min[T cmp.Ordered](x, y T) T {
	// ...
}
----

In this case, the type parameter list also has a type for each parameter.
It is called a _type constraint_, and it defines a _set of types_.
It is called _type constraint_ because it _constrains_ the types that it accepts.
In this example, the `cmp.Ordered` (or `constraints.Ordered in Go 1.18 and 1.19) type constraint means that `T` can be any type that allows its values to be ordered in some way, and therefore, be compared in terms of which value domes first or after the other value in some sense.

It means integers, strings, floats satisfy `cmp.Ordered` and therefore are valid values to be passed to `min()`, but types like booleans or struct do not satisfy `cmp.Ordered`, and therefore would not be valid input values to `min()`.

[NOTE]
====
As of this writing (Feb 2024 and Go 1.23), the type `bool` does implement comparison operators.
That is, we cannot do things like this:

[source,go]
----
if false < true
// ~ invalid operation: false < true (operator < not
// ~ defined on untyped bool)

// Or

x := min[bool](false, true)
// ~ bool does not satisfy cmp.Ordered (bool missing in ~int |
// ~ ~int8 | ~int16 | ~int32 | ~int64 | ~uint | ~uint8 | ~uint16 |
// ~ ~uint32 | ~uint64 | ~uintptr | ~float32 | ~float64 | ~string)
----

Therefore, `bool` is a type that does not satisfy `cmp.Ordered` constraint.
====

== Type constraints are interfaces

An interface defines a set of methods.
Any type that implements that set of methods implements that interface.

Another way to look at it is that an interface defines a set of types, which is where the following syntax in Go comes from:

[source,go]
----
type MyType interface {
	T1 | T2 | Tₙ
----

Operators like `<` or `>` are not methods.
So how come type constraints are interfaces?

[source,go]
----
type Ordered interface {
	Integer | Float | ~string
}
----
[NOTE]
====
Note that there are no methods in the `Ordered` interface.
It is really just defining a set of types.
====

The vertical bar expresses an union of the types.
`Integer` `Float` are interfaces themselves.

The _tilde_ “~” is a new token introduced in Go 1.18.
In short, it means `~T` the set of all types with underlying type `T`.
In our example, `~string` means all types that have the underlying `string` type.

A type constraint has two functions:

* The type set of type constraint is the set of all valid type arguments.
* If all types in a constraint support a certain operation, that operation may be used with the respective type parameter (even though there are exceptions or restrictions to this for a few special cases).

== Constraint literals (inline constraints)

Take this type constraint (with inline interfaces):

[source,go]
----
[S interface{ ~[]E }, E interface{}]
----

Go 1.8 added some syntax sugar so `interface{ ~[]E }` can be shortened to simply `~[]E`, so the type constraint can be written as:

[source,go]
----
[S ~[]E, E interface{}]
----

Also, the empty interface `interface{}` got an alias `any`, the type constraint can be even written like this:

[source,go]
----
[S ~[]E, any]
----

== References

* link:https://www.youtube.com/watch?v=Pa_e9EeCdy8[ GopherCon 2021: Generics! - Robert Griesemer & Ian Lance Taylor (Youtube)^].
